<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yxxu&#39;s Blog</title>
  
  <subtitle>To Be a Better Me</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-06T04:59:24.957Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yxxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（三）</title>
    <link href="http://yoursite.com/2018/04/06/%E8%AF%BB-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/06/读-《深入理解javascript原型和闭包》总结（三）/</id>
    <published>2018-04-06T02:58:44.000Z</published>
    <updated>2018-04-06T04:59:24.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个</p><p><strong><em>其实这是一个压栈出栈的过程——执行上下文栈</em></strong></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/232122300768665.png?raw=true" alt=""></p><p>有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。<br>要说闭包，咱们还得先从自由变量和作用域说起。</p><a id="more"></a><h3 id="简介【作用域】"><a href="#简介【作用域】" class="headerlink" title="简介【作用域】"></a>简介【作用域】</h3><p>“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。</p><p><strong><em>javascript除了全局作用域之外，只有函数可以创建的作用域。</em></strong></p><p><strong><em>我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式</em></strong></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/241708372951952.png?raw=true" alt=""></p><p>全局代码和fn、bar两个函数都会形成一个作用域。而且，<strong><em>作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</em></strong>。例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级</p><p><strong><em>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</em></strong></p><h3 id="【作用域】和【上下文环境】"><a href="#【作用域】和【上下文环境】" class="headerlink" title="【作用域】和【上下文环境】"></a>【作用域】和【上下文环境】</h3><p>除了全局作用域之外，每个函数都会创建自己的作用域，<strong><em>作用域在函数定义时就已经确定了。而不是在函数调用时确定。</em></strong></p><p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250814158269779.png?raw=true" alt=""></p><p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250814386853995.png?raw=true" alt=""></p><p>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815006238997.png?raw=true" alt=""></p><p>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815248579200.png?raw=true" alt=""></p><p>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250815435609914.png?raw=true" alt=""></p><p>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250816112012394.png?raw=true" alt=""></p><p>最后我们可以把以上这几个图片连接起来看看。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/250816269984619.png?raw=true" alt=""></p><p><strong><em>作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值</em></strong>。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<strong><em>作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了</em></strong>。</p><p><strong><em>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</em></strong></p><h3 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h3><p>自由变量： 在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">20</span>;</div><div class="line">  <span class="built_in">console</span>.log(x + b); <span class="comment">// 这里的 X 就是一个自由变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    fn();   <span class="comment">// 10 , 而不是 20</span></div><div class="line">  &#125;)()</div><div class="line">&#125;</div><div class="line"></div><div class="line">show(fn);</div></pre></td></tr></table></figure><p><strong><em>自由变量要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记</em></strong> — 这就是所谓的“静态作用域”</p><p>作用域的过程</p><p>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</p><p>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</p><p>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；<br>第四步，跳转到第一步。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong><em>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。</em></strong></p><p><strong><em>你只需要知道闭包应用的两种情况即可——函数作为返回值，函数作为参数传递</em></strong></p><p>第一，函数作为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> max = <span class="number">10</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &gt; max) &#123;</div><div class="line">      <span class="built_in">console</span>.log(x);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = fn()</div><div class="line"></div><div class="line">f1(<span class="number">15</span>)</div></pre></td></tr></table></figure><p>第二，函数作为参数被传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = <span class="number">10</span>,</div><div class="line">    fn = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (x &gt; max) &#123;</div><div class="line">        <span class="built_in">console</span>.log(x);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> max = <span class="number">100</span>;</div><div class="line">  f(<span class="number">15</span>);</div><div class="line">&#125;)(fn);</div></pre></td></tr></table></figure><p>函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p><p>演示例子：</p><p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260749349988764.png?raw=true" alt=""></p><p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260750319351092.png?raw=true" alt=""></p><p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p><p>因此，这里的fn()上下文环境不能被销毁，还依然存在与执行上下文栈中。</p><p>——即，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260957500455644.png?raw=true" alt=""></p><p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/260958057327369.png?raw=true" alt=""></p><p>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p><p>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</p><p>第五步，执行完20行就是上下文环境的销毁过程</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;执行上下文栈&quot;&gt;&lt;a href=&quot;#执行上下文栈&quot; class=&quot;headerlink&quot; title=&quot;执行上下文栈&quot;&gt;&lt;/a&gt;执行上下文栈&lt;/h3&gt;&lt;p&gt;执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;其实这是一个压栈出栈的过程——执行上下文栈&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/232122300768665.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。&lt;br&gt;要说闭包，咱们还得先从自由变量和作用域说起。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（二）</title>
    <link href="http://yoursite.com/2018/04/06/%E8%AF%BB-%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/06/读-《深入理解javascript原型和闭包》总结（二）/</id>
    <published>2018-04-06T01:43:11.000Z</published>
    <updated>2018-04-06T03:59:42.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>JavaScript 中的继承是通过原型链来体现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line">f1.a = <span class="number">10</span>;</div><div class="line"></div><div class="line">Foo.prototype.a = <span class="number">100</span>;</div><div class="line">Foo.prototype.b = <span class="number">200</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f1.a); <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(f1.b); <span class="comment">// 200</span></div></pre></td></tr></table></figure><p>f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为<code>f1.__proto__</code>指向的是<code>Foo.prototype</code></p><p><strong><em>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是原型链</em></strong></p><p><strong><em>如何区分一个属性到底是基本的还是从原型中找到的 —- hasOwnProperty</em></strong></p><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p><p>每个函数都有call，apply方法，都有length，arguments，caller等属性。函数由Function函数创建，因此继承的Function.prototype中的方法。Function.prototype继承自Object.prototype的方法，<code>Function.prototype.__proto__</code>指向Object.prototype</p><p>JavaScript对象属性是可以随时改动的，如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><a id="more"></a><h3 id="执行上下文（一）"><a href="#执行上下文（一）" class="headerlink" title="执行上下文（一）"></a>执行上下文（一）</h3><p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的，</p><p>第一种情况<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221744084828533.png?raw=true" alt="验证"></p><p>第二种情况<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221744319354566.png?raw=true" alt=""></p><p>第三种情况，<br><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221745066078791.png?raw=true" alt=""></p><p>第一种情况：只是对变量进行声明（并没有赋值）。</p><p>第二种情况：直接给this赋值。这也是“准备工作”情况要做的事情之一</p><p>第三种情况：需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p><p>在准备工作中完成了哪些任务（<strong><em>重点</em></strong>）</p><hr><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值</li></ul><hr><p><strong><em>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</em></strong></p><p>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。<strong><em>这个“代码段”其实分三种情况——全局代码，函数体，eval代码。</em></strong></p><p>所谓“代码段”就是一段文本形式的代码</p><ol><li>全局代码是一种</li><li>eval代码接受的也是一段文本形式的代码</li><li>函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。</li></ol><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221746370927602.png?raw=true" alt=""></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221747371078703.png?raw=true" alt=""></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/221746583578531.png?raw=true" alt=""></p><h3 id="执行上下文（下）"><a href="#执行上下文（下）" class="headerlink" title="执行上下文（下）"></a>执行上下文（下）</h3><p>执行上下文环境中有如何数据：</p><ul><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ul><p>如果在函数中，除了上面的数据之外，还会有其他数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line">fn(<span class="number">10</span>)</div></pre></td></tr></table></figure><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，<strong><em>函数每被调用一次，都会产生一个新的执行上下文环境。</em></strong> 因为不同的调用可能就会有不同的参数。</p><p>另外一点不同在于，<strong><em>函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域</em></strong></p><p>总结：全局代码的上下文环境数据内容为：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>普通变量（包括函数表达式），如:var a=10;</td><td>声明(默认赋值为undefined)</td></tr><tr><td>函数声明,如:function fn(){}</td><td>赋值</td></tr><tr><td>this</td><td>赋值</td></tr></tbody></table><p>如果代码段是函数体，在此基础上需要附加：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>参数</td><td>赋值</td></tr><tr><td>arguments</td><td>赋值</td></tr><tr><td>自由变量的取值作用域</td><td>赋值</td></tr></tbody></table><p>给执行上下文环境下一个通俗的定义——<strong><em>在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</em></strong></p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><strong><em>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</em></strong><br>因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p><h6 id="情况1：-构造函数"><a href="#情况1：-构造函数" class="headerlink" title="情况1： 构造函数"></a>情况1： 构造函数</h6><p>构造函数就是用new对象的函数。所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'xxx'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1991</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(f1.name);</div><div class="line"><span class="built_in">console</span>.log(f1.year);</div></pre></td></tr></table></figure><p>以上代码可以看出，<strong><em>如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象</em></strong></p><p>注意： 上面的情况仅限 new Foo() 的情况，即Foo函数作为构造函数的情况。</p><h6 id="情况2：函数作为对象的一个属性"><a href="#情况2：函数作为对象的一个属性" class="headerlink" title="情况2：函数作为对象的一个属性"></a>情况2：函数作为对象的一个属性</h6><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.fn();</div></pre></td></tr></table></figure><p>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象</p><h6 id="情况3：函数用call或者apply调用"><a href="#情况3：函数用call或者apply调用" class="headerlink" title="情况3：函数用call或者apply调用"></a>情况3：函数用call或者apply调用</h6><p>当一个函数被call和apply调用时，this的值就取传入的对象的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  x: <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn.call(obj); <span class="comment">// Object &#123;x: 10&#125;  10</span></div></pre></td></tr></table></figure><h6 id="情况4：全局-amp-调用普通函数"><a href="#情况4：全局-amp-调用普通函数" class="headerlink" title="情况4：全局 &amp; 调用普通函数"></a>情况4：全局 &amp; 调用普通函数</h6><p>在全局环境下，this永远是window，这个应该没有非议。</p><p>普通函数在调用时，其中的this也都是window</p><p>下面的情况需要注意下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  x: <span class="number">10</span>,</div><div class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</div><div class="line">    &#125;</div><div class="line">    f()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p><p>函数f虽然是在obj.fn内部定义的，但是它仍然是一个普通的函数，this仍然指向window</p><h6 id="补充-—-在构造函数的prototype中，this代表着什么。"><a href="#补充-—-在构造函数的prototype中，this代表着什么。" class="headerlink" title="补充 — 在构造函数的prototype中，this代表着什么。"></a>补充 — 在构造函数的prototype中，this代表着什么。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'xxx'</span></div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1991</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Fn.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn()</div><div class="line">f1.getName();</div></pre></td></tr></table></figure><p>如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。</p><p><strong><em>其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;JavaScript 中的继承是通过原型链来体现的。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Foo();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;f1.a = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Foo.prototype.a = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Foo.prototype.b = &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.a); &lt;span class=&quot;comment&quot;&gt;//10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(f1.b); &lt;span class=&quot;comment&quot;&gt;// 200&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为&lt;code&gt;f1.__proto__&lt;/code&gt;指向的是&lt;code&gt;Foo.prototype&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着&lt;code&gt;__proto__&lt;/code&gt;这条链向上找，这就是原型链&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;如何区分一个属性到底是基本的还是从原型中找到的 —- hasOwnProperty&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。&lt;/p&gt;
&lt;p&gt;每个函数都有call，apply方法，都有length，arguments，caller等属性。函数由Function函数创建，因此继承的Function.prototype中的方法。Function.prototype继承自Object.prototype的方法，&lt;code&gt;Function.prototype.__proto__&lt;/code&gt;指向Object.prototype&lt;/p&gt;
&lt;p&gt;JavaScript对象属性是可以随时改动的，如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>读 《深入理解javascript原型和闭包》总结（一）</title>
    <link href="http://yoursite.com/2018/01/10/%E8%AF%BB%20%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3javascript%E5%8E%9F%E5%9E%8B%E5%92%8C%E9%97%AD%E5%8C%85%E3%80%8B%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/10/读 《深入理解javascript原型和闭包》总结（一）/</id>
    <published>2018-01-10T09:52:32.000Z</published>
    <updated>2018-04-06T03:57:11.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一切都是对象"><a href="#一切都是对象" class="headerlink" title="一切都是对象"></a>一切都是对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);    <span class="comment">// undefined</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);   <span class="comment">// number</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'abc'</span>); <span class="comment">// string</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);  <span class="comment">// boolean</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);  <span class="comment">//function</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> [<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">true</span>]);  <span class="comment">//object</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span> &#125;);  <span class="comment">//object</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);  <span class="comment">//object</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>));  <span class="comment">//object</span></div><div class="line">&#125;</div><div class="line">show();</div></pre></td></tr></table></figure><p>（undefined, number, string, boolean）属于简单的值类型，不是对象。（函数、数组、对象、null、new Number(10)、）属于引用类型，都是对象。（引用类型都是对象）</p><p><strong><em> 判断一个变量是不是对象非常简单。值类型的类型判断用<code>typeof</code>，引用类型的类型判断用<code>instanceof</code>。  </em></strong></p><p>java中的对象是通过<code>new</code>一个<code>class</code>创建的。对于属性、方法、字段都是非常严格的。但是<code>javascript</code>的对象比较随意–数组是对象，函数式对象，对象还是对象。对象里面的一切都是属性（ <strong><em> 方法也是一种属性 </em></strong> ），属性表示为键值对的形式。<strong><em> 对象是属性的集合 </em></strong></p><p>JavaScript中的对象可以任意的扩展属性，没有<code>class</code>的约束。</p><a id="more"></a><hr><h3 id="函数和对象的关系"><a href="#函数和对象的关系" class="headerlink" title="函数和对象的关系"></a>函数和对象的关系</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div></pre></td></tr></table></figure><p>函数是一种对象，你可以说数组是对象的一种，因为数组就像是对象的一个子集一样。函数和对象关系比较复杂。</p><p>通过下面的内容缕一缕</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'王福朋'</span>;</div><div class="line">    <span class="keyword">this</span>.year = <span class="number">1988</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Object</span>)); <span class="comment">// function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> (<span class="built_in">Array</span>)); <span class="comment">// function</span></div></pre></td></tr></table></figure><p>通过上述代码，可以得出：<code>对象都是通过函数来创建</code>。</p><h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a>prototype 原型</h3><p><strong><em> 每个函数都有一个属性叫做prototype </em></strong> 。这个prototype的属性值是一个对象（<strong><em>属性的集合，再次强调</em></strong>），默认的只有一个叫做<code>constructor</code>的属性，指向这个函数本身。</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/172121182841896.png?raw=true" alt="prototype"></p><p>Object</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/172130097842386.png?raw=true" alt="Object"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123; &#125;</div><div class="line">   Fn.prototype.name = <span class="string">'王福朋'</span>;</div><div class="line">   Fn.prototype.getYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">1988</span>;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> fn = <span class="keyword">new</span> Fn();</div><div class="line">   <span class="built_in">console</span>.log(fn.name);</div><div class="line">   <span class="built_in">console</span>.log(fn.getYear());</div></pre></td></tr></table></figure><p>Fn是一个函数，fn对象是从Fn函数new出来的，这样fn对象就可以调用Fn.prototype中的属性。</p><h3 id="隐式原型"><a href="#隐式原型" class="headerlink" title="隐式原型"></a>隐式原型</h3><p>每个对象都有一个隐藏的属性——<code>__proto__</code>，这个属性引用了创建这个对象的函数的prototype。即：<code>fn.__proto__ === Fn.prototype</code>。这里的<code>__proto__</code>成为“隐式原型”</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181509180812624.png?raw=true" alt="__proto__"></p><blockquote><p>总结：每个函数function都有一个prototype，即原型。每个对象都有一个<code>__proto__</code>，可成为隐式原型。特殊：Object.prototype是一个特例——它的<strong>proto</strong>指向的是null，切记切记</p></blockquote><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181510403153733.png?raw=true" alt="Object.prototype"></p><p>谁创建了函数？看下面的内容</p><p>函数也是对象，它也有<code>__proto__</code>。函数是被 Function 创建出来的。 —- 这里的 “F” 是大写</p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181511124714709.png?raw=true" alt="Function"></p><p>以上代码中，第一种方式是比较传统的函数创建方式，第二种是用new Functoin创建。</p><p>总结：自定义函数<code>Foo.__proto__</code>指向<code>Function.prototype</code>，<code>Object.__proto__</code>指向<code>Function.prototype</code></p><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181512068463597.png?raw=true" alt="总结"></p><blockquote><p>注意点：<code>Object.__proto__</code>指向<code>Function.prototype</code>，<code>Function.prototype</code>指向的对象，它的<code>__proto__</code>指向 <code>Object.prototype</code>。因为<code>Function.prototype</code>指向的对象也是一个普通的被<code>Object</code>创建的对象，所以也遵循基本的规则。</p></blockquote><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><strong><em> instanceof判断规则 </em></strong></p><p>Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p><p>Instanceof的判断队则是：<strong><em>沿着A的<strong>proto</strong>这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false</em></strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.console.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div></pre></td></tr></table></figure><p><img src="https://github.com/yxxuweb/markdownPhoto/blob/master/markdown/181637013624694.png?raw=true" alt="instanceof"></p><p>instanceof表示的就是一种继承关系，或者原型链的结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一切都是对象&quot;&gt;&lt;a href=&quot;#一切都是对象&quot; class=&quot;headerlink&quot; title=&quot;一切都是对象&quot;&gt;&lt;/a&gt;一切都是对象&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; x);    &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;// number&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;abc&#39;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;// boolean&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;);  &lt;span class=&quot;comment&quot;&gt;//function&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;]);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &amp;#123; &lt;span class=&quot;attr&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt; &amp;#125;);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Number&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));  &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;show();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;（undefined, number, string, boolean）属于简单的值类型，不是对象。（函数、数组、对象、null、new Number(10)、）属于引用类型，都是对象。（引用类型都是对象）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt; 判断一个变量是不是对象非常简单。值类型的类型判断用&lt;code&gt;typeof&lt;/code&gt;，引用类型的类型判断用&lt;code&gt;instanceof&lt;/code&gt;。  &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java中的对象是通过&lt;code&gt;new&lt;/code&gt;一个&lt;code&gt;class&lt;/code&gt;创建的。对于属性、方法、字段都是非常严格的。但是&lt;code&gt;javascript&lt;/code&gt;的对象比较随意–数组是对象，函数式对象，对象还是对象。对象里面的一切都是属性（ &lt;strong&gt;&lt;em&gt; 方法也是一种属性 &lt;/em&gt;&lt;/strong&gt; ），属性表示为键值对的形式。&lt;strong&gt;&lt;em&gt; 对象是属性的集合 &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript中的对象可以任意的扩展属性，没有&lt;code&gt;class&lt;/code&gt;的约束。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2017/10/25/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2017/10/25/跨域/</id>
    <published>2017-10-25T13:06:03.000Z</published>
    <updated>2018-01-10T09:46:13.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript跨域总结与解决办法"><a href="#JavaScript跨域总结与解决办法" class="headerlink" title="JavaScript跨域总结与解决办法"></a>JavaScript跨域总结与解决办法</h1><ul><li>什么是跨域</li><li>document.domain+iframe的设置</li><li>动态创建script</li><li>利用iframe和location.hash</li><li>window.name实现的跨域数据传输</li><li>使用HTML5 postMessage</li><li>利用flash</li></ul><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td><td>同一域名下</td><td>允许</td></tr><tr><td><a href="http://www.a.com/lab/a.js" target="_blank" rel="external">http://www.a.com/lab/a.js</a>  <a href="http://www.a.com/script/b.js" target="_blank" rel="external">http://www.a.com/script/b.js</a></td><td>同一域名下不同文件夹</td><td>允许</td></tr><tr><td><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a>    <a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a>  <a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> <a href="http://70.32.92.74/b.js" target="_blank" rel="external">http://70.32.92.74/b.js</a></td><td>域名和域名对应ip</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a>  <a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a>  <a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td><td>同一域名，不同二级域名（同上）</td><td>不允许（cookie这种情况下也不允许访问）</td></tr><tr><td><a href="http://www.cnblogs.com/a.js" target="_blank" rel="external">http://www.cnblogs.com/a.js</a>    <a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><a id="more"></a><p>特别注意两点：<br>第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，<br>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。</p><p>“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match</p><h5 id="1-document-domain-iframe的设置"><a href="#1-document-domain-iframe的设置" class="headerlink" title="1. document.domain+iframe的设置"></a>1. document.domain+iframe的设置</h5><p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决</p><p>www.a.com上的a.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</div><div class="line"><span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">ifr.src = <span class="string">'http://script.a.com/b.html'</span>;</div><div class="line">ifr.style.display = <span class="string">'none'</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(ifr);</div><div class="line">ifr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> doc = ifr.contentDocument || ifr.contentWindow.document;</div><div class="line">    <span class="comment">// 在这里操纵b.html</span></div><div class="line">    alert(doc.getElementsByTagName(<span class="string">"h1"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>script.a.com上的b.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</div></pre></td></tr></table></figure><p>问题：<br>1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。<br>2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p><h5 id="2-动态创建script"><a href="#2-动态创建script" class="headerlink" title="2. 动态创建script"></a>2. 动态创建script</h5><p>这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">js.onload = js.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.readyState || <span class="keyword">this</span>.readyState === <span class="string">'loaded'</span> || <span class="keyword">this</span>.readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">        <span class="comment">// callback在此处执行</span></div><div class="line">        js.onload = js.onreadystatechange = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h5 id="3-利用iframe和location-hash"><a href="#3-利用iframe和location-hash" class="headerlink" title="3. 利用iframe和location.hash"></a>3. 利用iframe和location.hash</h5><p>原理是利用location.hash来进行传值。在url： <a href="http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。" target="_blank" rel="external">http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可以利用hash值来进行数据传递，当然数据容量是有限的。</a></p><p>假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。</p><p>先是a.com下的文件cs1.html文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">startRequest</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">    ifr.style.display = <span class="string">'none'</span>;</div><div class="line">    ifr.src = <span class="string">'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo'</span>;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(ifr);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkHash</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">var</span> data = location.hash ? location.hash.substring(<span class="number">1</span>) : <span class="string">''</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">console</span>.log) &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'Now the data is '</span>+data);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(e) &#123;&#125;;</div><div class="line">&#125;</div><div class="line">setInterval(checkHash, <span class="number">2000</span>);</div></pre></td></tr></table></figure><p>cnblogs.com域名下的cs2.html:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模拟一个简单的参数处理操作</span></div><div class="line"><span class="keyword">switch</span>(location.hash)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'#paramdo'</span>:</div><div class="line">        callBack();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'#paramset'</span>:</div><div class="line">        <span class="comment">//do something……</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callBack</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        parent.location.hash = <span class="string">'somedata'</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="comment">// ie、chrome的安全机制无法修改parent.location.hash，</span></div><div class="line">        <span class="comment">// 所以要利用一个中间的cnblogs域下的代理iframe</span></div><div class="line">        <span class="keyword">var</span> ifrproxy = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">        ifrproxy.style.display = <span class="string">'none'</span>;</div><div class="line">        ifrproxy.src = <span class="string">'http://a.com/test/cscript/cs3.html#somedata'</span>;    <span class="comment">// 注意该文件在"a.com"域下</span></div><div class="line">        <span class="built_in">document</span>.body.appendChild(ifrproxy);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>a.com下的域名cs3.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值</span></div><div class="line">parent.parent.location.hash = self.location.hash.substring(<span class="number">1</span>);</div></pre></td></tr></table></figure><p>当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等……</p><h5 id="4-window-name实现的跨域数据传输"><a href="#4-window-name实现的跨域数据传输" class="headerlink" title="4. window.name实现的跨域数据传输"></a>4. window.name实现的跨域数据传输</h5><p>有三个页面：</p><p>a.com/app.html：应用页面。<br>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p><ol><li>在应用页面（a.com/app.html）中创建一个iframe，把其src指向数据页面（b.com/data.html）。<br>数据页面会把数据附加到这个iframe的window.name上</li></ol><p>data.html 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">window</span>.name = <span class="string">'I was there!'</span>;    <span class="comment">// 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右</span></div><div class="line">    <span class="comment">//// 数据格式可以自定义，如json、字符串</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><p>在应用页面（a.com/app.html）中监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。</p><p>app.html部分代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="keyword">var</span> state = <span class="number">0</span>, </div><div class="line">    iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>),</div><div class="line">    loadfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">var</span> data = iframe.contentWindow.name;    <span class="comment">// 读取数据</span></div><div class="line">            alert(data);    <span class="comment">//弹出'I was there!'</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</div><div class="line">            state = <span class="number">1</span>;</div><div class="line">            iframe.contentWindow.location = <span class="string">"http://a.com/proxy.html"</span>;    <span class="comment">// 设置的代理文件</span></div><div class="line">        &#125;  </div><div class="line">    &#125;;</div><div class="line">    iframe.src = <span class="string">'http://b.com/data.html'</span>;</div><div class="line">    <span class="keyword">if</span> (iframe.attachEvent) &#123;</div><div class="line">        iframe.attachEvent(<span class="string">'onload'</span>, loadfn);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        iframe.onload  = loadfn;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    iframe.contentWindow.document.write(<span class="string">''</span>);</div><div class="line">    iframe.contentWindow.close();</div><div class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h5 id="5-使用HTML5-postMessage"><a href="#5-使用HTML5-postMessage" class="headerlink" title="5. 使用HTML5 postMessage"></a>5. 使用HTML5 postMessage</h5><p>Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+  支持这个API</p><p>otherWindow.postMessage(message, targetOrigin);<br>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。<br>message: 所要发送的数据，string类型。<br>targetOrigin: 用于限制otherWindow，“*”表示不作限制</p><p>a.com/index.html中的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;iframe id=<span class="string">"ifr"</span> src=<span class="string">"b.com/index.html"</span>&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.getElementById(<span class="string">'ifr'</span>);</div><div class="line">    <span class="keyword">var</span> targetOrigin = <span class="string">'http://b.com'</span>;  <span class="comment">// 若写成'http://b.com/c/proxy.html'效果一样</span></div><div class="line">                                        <span class="comment">// 若写成'http://c.com'就不会执行postMessage了</span></div><div class="line">    ifr.contentWindow.postMessage(<span class="string">'I was there!'</span>, targetOrigin);</div><div class="line">&#125;;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>b.com/index.html中的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="comment">// 通过origin属性判断消息来源地址</span></div><div class="line">        <span class="keyword">if</span> (event.origin == <span class="string">'http://a.com'</span>) &#123;</div><div class="line">            alert(event.data);    <span class="comment">// 弹出"I was there!"</span></div><div class="line">            alert(event.source);  <span class="comment">// 对a.com、index.html中window对象的引用</span></div><div class="line">             <span class="comment">// 但由于同源策略，这里event.source不可以访问window对象</span></div><div class="line">        &#125;</div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript跨域总结与解决办法&quot;&gt;&lt;a href=&quot;#JavaScript跨域总结与解决办法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript跨域总结与解决办法&quot;&gt;&lt;/a&gt;JavaScript跨域总结与解决办法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;什么是跨域&lt;/li&gt;
&lt;li&gt;document.domain+iframe的设置&lt;/li&gt;
&lt;li&gt;动态创建script&lt;/li&gt;
&lt;li&gt;利用iframe和location.hash&lt;/li&gt;
&lt;li&gt;window.name实现的跨域数据传输&lt;/li&gt;
&lt;li&gt;使用HTML5 postMessage&lt;/li&gt;
&lt;li&gt;利用flash&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h3&gt;&lt;p&gt;JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;URL&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;是否允许通信&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/a.js&lt;/a&gt; &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名下&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/lab/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/lab/a.js&lt;/a&gt;  &lt;a href=&quot;http://www.a.com/script/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/script/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名下不同文件夹&lt;/td&gt;
&lt;td&gt;允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com:8000/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com:8000/a.js&lt;/a&gt;    &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同端口&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;https://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同协议&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/a.js&lt;/a&gt; &lt;a href=&quot;http://70.32.92.74/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://70.32.92.74/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;域名和域名对应ip&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;http://script.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://script.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;主域相同，子域不同&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.a.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/a.js&lt;/a&gt;  &lt;a href=&quot;http://a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;同一域名，不同二级域名（同上）&lt;/td&gt;
&lt;td&gt;不允许（cookie这种情况下也不允许访问）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/a.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/a.js&lt;/a&gt;    &lt;a href=&quot;http://www.a.com/b.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.a.com/b.js&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;不同域名&lt;/td&gt;
&lt;td&gt;不允许&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>javascript类数组(ArrayLike)转化成数组</title>
    <link href="http://yoursite.com/2017/10/18/javascript%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2017/10/18/javascript类数组转化成数组/</id>
    <published>2017-10-18T13:58:27.000Z</published>
    <updated>2017-10-25T13:54:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript类数组转化成数组"><a href="#javascript类数组转化成数组" class="headerlink" title="javascript类数组转化成数组"></a>javascript类数组转化成数组</h1><h2 id="什么是类数组（ArrayLike）？"><a href="#什么是类数组（ArrayLike）？" class="headerlink" title="什么是类数组（ArrayLike）？"></a>什么是类数组（ArrayLike）？</h2><p>ArrayLike（类数组/伪数组）即拥有数组的一部分行为,例如 arguments, NodeList等！他们拥有<strong><em>length</em></strong>属性，但是却不能用一些数组的方法，如 push，pop等等</p><p>常见的ArrayLike有下面的这几个：</p><ul><li>Arguments</li><li>NodeList</li><li>StyleSheetList</li><li>HTMLCollection</li><li>HTMLFormControlsCollection (继承HTMLCollection)</li><li>HTMLOptionsCollection(继承HTMLCollection)</li><li>HTMLAllCollection</li><li>DOMTokenList</li></ul><a id="more"></a><h2 id="Array-Like-to-Array"><a href="#Array-Like-to-Array" class="headerlink" title="Array-Like to Array"></a>Array-Like to Array</h2><p>在项目开发中，经常遇到需要把 Array-Like Objects 转为 Array 类型，使之能用数组的一些方法。下面列出几种方法：</p><ul><li>for循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++)</div><div class="line">  arr[i] = <span class="built_in">arguments</span>[i];</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure><ul><li>Array.prototype.slice.call(array-like object)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure><p>或者可以用 <strong><em>[]</em></strong> 代替 Array.prototype</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure><p>原理： slice的内部实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//slice的内部实现</span></div><div class="line"><span class="built_in">Array</span>.prototype.slice = <span class="function"><span class="keyword">function</span>(<span class="params">start,end</span>)</span>&#123;  </div><div class="line">      <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();  </div><div class="line">      start = start || <span class="number">0</span>;  </div><div class="line">      end = end || <span class="keyword">this</span>.length; <span class="comment">//this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键  </span></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = start; i &lt; end; i++)&#123;  </div><div class="line">           result.push(<span class="keyword">this</span>[i]);  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">return</span> result;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>兼容 IE8 以下的浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toArray = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(s);  </div><div class="line">    &#125; <span class="keyword">catch</span>(e)&#123;  </div><div class="line">            <span class="keyword">var</span> arr = [];  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = s.length; i &lt; len; i++)&#123;  </div><div class="line">                <span class="comment">//arr.push(s[i]);  </span></div><div class="line">                 arr[i] = s[i];     <span class="comment">//据说这样比push快</span></div><div class="line">            &#125;  </div><div class="line">             <span class="keyword">return</span> arr;  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Array.from()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"helloworld"</span>;</div><div class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(str);</div></pre></td></tr></table></figure><h3 id="Array-Like-to-Array-注意点"><a href="#Array-Like-to-Array-注意点" class="headerlink" title="Array-Like to Array 注意点"></a>Array-Like to Array 注意点</h3><p>arguments 转换成数组的时候经常会把 <strong><em>Array.prototype.slice.call(arguments)</em></strong> 用更短的写法 <strong><em> [].slice.call(arguments)</em></strong></p><p>这个将导致Chrome和Node中使用的V8引擎跳过对其的优化，使其性能相当慢。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript类数组转化成数组&quot;&gt;&lt;a href=&quot;#javascript类数组转化成数组&quot; class=&quot;headerlink&quot; title=&quot;javascript类数组转化成数组&quot;&gt;&lt;/a&gt;javascript类数组转化成数组&lt;/h1&gt;&lt;h2 id=&quot;什么是类数组（ArrayLike）？&quot;&gt;&lt;a href=&quot;#什么是类数组（ArrayLike）？&quot; class=&quot;headerlink&quot; title=&quot;什么是类数组（ArrayLike）？&quot;&gt;&lt;/a&gt;什么是类数组（ArrayLike）？&lt;/h2&gt;&lt;p&gt;ArrayLike（类数组/伪数组）即拥有数组的一部分行为,例如 arguments, NodeList等！他们拥有&lt;strong&gt;&lt;em&gt;length&lt;/em&gt;&lt;/strong&gt;属性，但是却不能用一些数组的方法，如 push，pop等等&lt;/p&gt;
&lt;p&gt;常见的ArrayLike有下面的这几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Arguments&lt;/li&gt;
&lt;li&gt;NodeList&lt;/li&gt;
&lt;li&gt;StyleSheetList&lt;/li&gt;
&lt;li&gt;HTMLCollection&lt;/li&gt;
&lt;li&gt;HTMLFormControlsCollection (继承HTMLCollection)&lt;/li&gt;
&lt;li&gt;HTMLOptionsCollection(继承HTMLCollection)&lt;/li&gt;
&lt;li&gt;HTMLAllCollection&lt;/li&gt;
&lt;li&gt;DOMTokenList&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/16/hello-world/"/>
    <id>http://yoursite.com/2017/10/16/hello-world/</id>
    <published>2017-10-16T13:20:10.838Z</published>
    <updated>2017-12-17T09:57:16.601Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
